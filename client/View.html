<!-- @format -->

<script>
  import {onMount, onDestroy} from 'svelte'
  import {replace, push} from 'svelte-spa-router'

  import QR from './QR.html'
  import Json from './Json.html'
  import LuaCode from './LuaCode.html'
  import Markdown from './Markdown.html'
  import MultiField from './MultiField.html'
  import EventRow from './EventRow.html'

  import account from './accountStore'
  import * as toast from './toast'

  export let params
  var contract
  var events = []

  var deletable = false

  var methods = []
  var usesauth = {}
  var payloadfields = {}
  var payloadfieldtypes = {}

  var nextcall
  resetNextCall()

  onMount(() => {
    loadContract()
  })

  async function loadContract() {
    let r = await fetch('/~/contract/' + params.ctid)
    if (r.status == 404) replace('/notfound')
    contract = (await r.json()).value

    parseCode(contract.code)
    nextcall.method = methods.length ? methods[0] : null

    r = await fetch('/~/contract/' + params.ctid + '/events')
    events = (await r.json()).value

    deletable =
      contract.funds === 0 &&
      events.length < 4 &&
      new Date() - new Date(Date.parse(contract.created_at)) < 3600000
  }

  function parseCode(code) {
    methods = []
    code.replace(/[\n^]function +([^_][\w_]+) *\(/g, (_, methodName) =>
      methods.push(methodName)
    )

    usesauth = {}
    var infunction = null
    var fieldmap = null
    code.split('\n').forEach(line => {
      let start_function = line.match(/^function ([^_][_\w]+) *\( *\)/)
      if (start_function) {
        infunction = start_function[1]
        fieldmap = {}
      }

      if (infunction) {
        if (line.match(/\b(account.send|account.id|account.get_balance)\b/)) {
          usesauth[infunction] = true
        }

        line.replace(/\bcall.payload\.([\w_]+)/g, (_, pf) => {
          fieldmap[pf] = true
        })
      }

      if (line.match(/^end\b/) && infunction) {
        payloadfields[infunction] = Object.keys(fieldmap || {})
        infunction = null
        fieldmap = null
      }
    })
  }

  function resetNextCall(id) {
    if (id && nextcall.id !== id) return

    nextcall = {
      msatoshi: 0,
      payload: {},
      method: methods.length ? methods[0] : null,
      includeCallerSession: false
    }
  }

  async function prepareCall(e) {
    e.preventDefault()

    let {method, msatoshi, payload, includeCallerSession} = nextcall
    let qr =
      $account.session && includeCallerSession
        ? `?session=${$account.session}`
        : ''

    let r = await fetch('/~/contract/' + params.ctid + '/call' + qr, {
      method: 'post',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        method,
        msatoshi,
        payload
      })
    })
    let resp = await r.json()

    if (!resp.ok) {
      toast.warning(resp.error)
      return
    }

    let {id, invoice} = resp.value
    nextcall.invoice = invoice
    nextcall.id = id
  }

  function abandonCall(e) {
    e.preventDefault()
    resetNextCall()
  }

  async function deleteContract(e) {
    e.preventDefault()

    let r = await fetch('/~/contract/' + params.ctid, {method: 'delete'})
    let resp = await r.json()
    if (resp.ok) {
      toast.success('contract deleted!')
      push('/contracts')
    } else {
      toast.warning(resp.error)
    }
  }

  function setMsatoshi(e) {
    nextcall.msatoshi = parseInt(e.target.value) * 1000
  }

  function setPayloadField(pf, e) {
    var jsonvalue
    if (e.detail === '') {
      jsonvalue = undefined
    } else {
      try {
        jsonvalue = JSON.parse(e.detail)
      } catch (err) {
        jsonvalue = e.detail
      }
    }

    nextcall.payload[pf] = jsonvalue
  }

  function renderPayloadField(pf) {
    return nextcall.payload[pf] === undefined
      ? ''
      : typeof nextcall.payload[pf] === 'string'
      ? nextcall.payload[pf]
      : JSON.stringify(nextcall.payload[pf])
  }

  var es
  onMount(() => {
    startEventSource()
  })

  onDestroy(() => {
    es.close()
  })

  function startEventSource() {
    es = new EventSource('/~/contract/' + params.ctid + '/stream')
    es.onerror = e => console.log('contract sse error', e.data)
    es.addEventListener('contract-created', e => {
      let data = JSON.parse(e.data)
      toast.success(`contract ${data.id} created!`)
      setTimeout(loadContract, 2300)
    })
    es.addEventListener('contract-error', e => {
      let data = JSON.parse(e.data)
      toast.warning(`${data.kind} error creating contract: ${data.message}`)
    })
    es.addEventListener('call-run-event', e => {
      let data = JSON.parse(e.data)
      switch (data.kind) {
        case 'start':
          toast.info(`call ${data.id} started...`)
          break
        case 'print':
          toast.info(`call ${data.id} printed: <code>${data.message}</code>`)
          break
        case 'function':
          toast.info(
            `call ${data.id} used a function: <code>${data.message}</code>`
          )
          account.refresh()
          break
      }
    })
    es.addEventListener('call-made', e => {
      let data = JSON.parse(e.data)
      setTimeout(() => {
        toast.success(`call ${data.id} made!`)
        resetNextCall(data.id)
        loadContract()
      }, 1000)
    })
    es.addEventListener('call-error', e => {
      let data = JSON.parse(e.data)

      if (data.kind === 'internal') {
        toast.error(`internal error, please notify: ${data.message}`)
      } else if (data.kind === 'runtime') {
        toast.warning(`raised error: <pre>${data.message}</pre>`, 30000)
      }

      resetNextCall(data.id)
    })
  }
</script>

<style>
  main {
    display: flex;
    flex-wrap: wrap;
  }
  #status {
    width: 58%;
  }
  #action {
    margin-left: 2%;
    width: 40%;
  }
  #action label {
    display: block;
    margin: 12px 2px;
  }
  #action input:not([type='checkbox']),
  #action select {
    padding: 4px;
    font-size: 1.2rem;
    background-color: var(--lightgrey);
  }
  button {
    cursor: pointer;
    margin: 12px;
    padding: 12px;
    font-size: 1.2rem;
    background-color: var(--yellow);
  }
  #events {
    margin-top: 2%;
    width: 100%;
  }
</style>

{#if !contract}
<div class="center">loading</div>
{:else if contract.invoice && !contract.invoice_paid}
<div class="center">
  <QR value="{contract.invoice}" />
  <p>pay to enable the contract</p>
</div>
{:else}
<main>
  <div id="status">
    <h1>
      {contract.name} {#if window.location.host !== 'etleneum.com' || deletable}
      <button on:click="{deleteContract}">delete</button>{/if}
    </h1>
    <div>{(contract.funds/1000).toFixed(3)} sat</div>
    <h4>state</h4>
    <Json value="{contract.state}" />
    <h4>readme</h4>
    <Markdown>{contract.readme}</Markdown>
    <h4>code</h4>
    <LuaCode>{contract.code}</LuaCode>
  </div>
  <div id="action">
    <h2>make a call</h2>
    {#if methods.length == 0 }
    <p>apparently this contract has no callable methods</p>
    {:else} {#if nextcall.invoice}
    <div class="center">
      <QR value="{nextcall.invoice}" />
      <p>pay to make the call</p>
      <button on:click="{abandonCall}">prepare a different call</button>
    </div>
    {:else}
    <form on:submit="{prepareCall}">
      <label
        >method:
        <select bind:value="{nextcall.method}">
          {#each methods as method}<option>{method}</option>{/each}
        </select>
        {#if usesauth[nextcall.method]}apparently this method requires you to be
        authenticated{/if}
      </label>
      <label
        >satoshi: <input type="number" min="0" value={nextcall.msatoshi/1000}
        on:input="{setMsatoshi}" /></label
      >
      {#each (payloadfields[nextcall.method] || []) as pf}
      <label
        >{pf}:
        <MultiField
          value="{renderPayloadField(pf)}"
          on:change="{e => setPayloadField(pf, e)}"
      /></label>
      {/each} {#if Object.keys(nextcall.payload).length > 0}
      <label>payload: <Json value="{nextcall.payload}" /> </label>
      {/if}
      <label
        >make this call authenticated with your account:
        <input
          type="checkbox"
          bind:checked="{nextcall.includeCallerSession}"
          disabled="{!$account.session}"
      /></label>
      <button>prepare call</button>
    </form>
    {/if} {/if}
  </div>
  <div id="events">
    <h2>contract (recent) history</h2>
    {#each events as event}
    <EventRow event="{event}" />
    {/each}
  </div>
</main>
{/if}
