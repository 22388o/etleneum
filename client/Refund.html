<!-- @format -->

<script>
  import bech32 from 'bech32'
  import {Buffer} from 'safe-buffer'
  import sha256 from 'sha.js/sha256'
  import {onMount} from 'svelte'

  import QR from './QR.html'

  var refunds
  var claimable = null
  var preimage

  onMount(async () => {
    let r = await fetch('/~/refunds')
    refunds = (await r.json()).value
  })

  function handlePreimage(e) {
    let hash = new sha256().update(Buffer.from(preimage, 'hex')).digest('hex')

    for (let i = 0; i < refunds.length; i++) {
      let refund = refunds[i]
      if (hash === refund.hash) {
        claimable = refund
      }
      break
    }
  }

  function lnurl(preimage) {
    return bech32.encode(
      'lnurl',
      bech32.toWords(
        `${location.origin}/lnurl/refund?preimage=${preimage}`
          .split('')
          .map(l => l.charCodeAt(0))
      ),
      1500
    )
  }
</script>

<style>
  #claim {
    margin: 20px auto;
  }
  input {
    width: 80%;
    display: block;
    text-align: center;
  }
  table {
    width: 100%;
  }
  td {
    padding: 2px 5px;
  }
  .hash {
    max-width: 400px;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  .claimable {
    background: var(--softblue);
    color: white;
  }
</style>

{#if !refunds}
<div class="center">
  loading
</div>
{:else}
<div id="claim" class="center">
  {#if claimable}
  <QR value="{lnurl(preimage)}" />
  {:else}
  <input
    on:input="{handlePreimage}"
    bind:value="{preimage}"
    placeholder="payment proof or preimage"
  />
  {/if}
</div>

<table>
  {#each refunds as refund (refund.hash)}
  <tr class:claimable="{claimable && refund.hash === claimable.hash}">
    <td class="hash">{refund.hash}</td>
    <td>{refund.time.split('T').join(' ').replace(/\..*/, '')}</td>
    <td>{(refund.msatoshi/1000).toFixed(3)} sat</td>
  </tr>
  {/each}
</table>

{/if}
